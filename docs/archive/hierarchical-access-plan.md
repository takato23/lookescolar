# Plan v2: Sistema de Acceso Jer√°rquico de Tokens
## üéØ **VERSI√ìN MEJORADA - Arquitectura Profesional**

> **Mejoras cr√≠ticas:** Separaci√≥n de dominios, seguridad real, performance, observabilidad completa

## Resumen Ejecutivo de Mejoras

### üèóÔ∏è **Modelo Claro de Dominios**
- **Separar Cursos de Personas/Familias** (hoy `subjects` est√° sobrecargado)
- **A√±adir `courses` y `course_members`** (familias ‚Üî cursos)
- **Usar `asset_subjects`** (assets ‚Üî personas/familias) para `/f/[token]` correcto
- **Relacionar carpetas con cursos**, no con familias (coherencia con nivel `/c`)

### üîê **Tokenizaci√≥n Unificada y Segura**
- **Tabla √∫nica `access_tokens`** con scope (event|course|family)
- **Hash del token** (no texto plano) + salt + prefijos legibles (E_, C_, F_)
- **Control granular:** `max_uses`, `can_download`, `revoked_at`, rate-limit
- **Auditor√≠a completa:** logs de acceso, m√©tricas reales

### ‚ö° **Consultas Can√≥nicas por Scope**
- **Funciones SQL** que resuelven "assets visibles por token" en un solo lugar
- **SECURITY DEFINER** para filtrar con service role (no RLS p√∫blico)
- **Performance:** √≠ndices covering, vistas materializadas opcionales

## An√°lisis: Sistema Actual vs. Propuesto v2

### ‚úÖ Lo que YA TENEMOS (Base s√≥lida)

**Infrastructure:**
```sql
-- ‚úÖ EVENTOS: Estructura base
events (id, name, school_name, date, active)

-- ‚úÖ SUBJECTS: Representa FAMILIAS (no cursos - error conceptual corregido)
subjects (id, event_id, first_name, last_name, type, couple_first_name, family_name)

-- ‚úÖ FOLDERS JER√ÅRQUICOS: Estructura completa
folders (id, name, parent_id, event_id, depth, is_published, share_token)

-- ‚úÖ ASSETS: Sistema de archivos
assets (id, folder_id, filename, original_path, preview_path)

-- ‚úÖ TOKENS B√ÅSICOS: Para migrar
subject_tokens (id, subject_id, token, expires_at, created_at, used_at)
```

**Servicios Existentes:**
- ‚úÖ `tokenService` ‚Üí Base para AccessTokenService
- ‚úÖ `folder-publish.service` ‚Üí Funciona, mantener
- ‚úÖ RLS policies para admin ‚Üí Mantener

### üöÄ **Lo que CONSTRUIMOS (Arquitectura v2)**

**1. Separaci√≥n de Dominios (Nueva Estructura)**
```sql
-- üÜï CURSOS: Entidad separada y clara
CREATE TABLE courses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id uuid NOT NULL REFERENCES events(id) ON DELETE CASCADE,
  name text NOT NULL,
  created_at timestamptz DEFAULT now(),
  UNIQUE (event_id, name)
);

-- üÜï MEMBRES√çAS: Familias pertenecen a cursos
CREATE TABLE course_members (
  course_id uuid NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  subject_id uuid NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
  PRIMARY KEY (course_id, subject_id)
);
CREATE INDEX idx_course_members_subject ON course_members(subject_id);

-- üÜï CARPETAS ‚Üî CURSOS: Relaci√≥n l√≥gica
CREATE TABLE folder_courses (
  folder_id uuid NOT NULL REFERENCES folders(id) ON DELETE CASCADE,
  course_id uuid NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  PRIMARY KEY (folder_id, course_id)
);
CREATE INDEX idx_folder_courses_course ON folder_courses(course_id);

-- üÜï ASSETS ‚Üî FAMILIAS: Etiquetado para /f/[token]
CREATE TABLE asset_subjects (
  asset_id uuid NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
  subject_id uuid NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
  PRIMARY KEY (asset_id, subject_id)
);
CREATE INDEX idx_asset_subjects_subject ON asset_subjects(subject_id);
CREATE INDEX idx_asset_subjects_asset ON asset_subjects(asset_id);
```

**2. Tokenizaci√≥n Unificada y Segura**
```sql
-- üÜï TABLA √öNICA: Todos los scopes en una tabla
CREATE TABLE access_tokens (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  scope text NOT NULL CHECK (scope IN ('event','course','family')),
  
  -- Recurso seg√∫n scope (solo uno no-null)
  event_id  uuid REFERENCES events(id)   ON DELETE CASCADE,
  course_id uuid REFERENCES courses(id)  ON DELETE CASCADE,
  subject_id uuid REFERENCES subjects(id) ON DELETE CASCADE,

  -- üîê SEGURIDAD: Hash + salt (nunca texto plano)
  token_hash bytea NOT NULL,        -- digest(plain_token || salt, 'sha256')
  salt bytea NOT NULL,              -- gen_random_bytes(16)
  token_prefix text NOT NULL,       -- primeros 8-10 chars para lookup r√°pido
  
  -- üéõÔ∏è CONTROL GRANULAR
  access_level text NOT NULL DEFAULT 'read_only' CHECK (access_level IN ('full','read_only')),
  can_download boolean NOT NULL DEFAULT false,
  max_uses int,                     -- null = ilimitado
  used_count int NOT NULL DEFAULT 0,
  last_used_at timestamptz,
  expires_at timestamptz,
  revoked_at timestamptz,

  -- üìä METADATOS
  created_at timestamptz DEFAULT now(),
  created_by uuid REFERENCES auth.users(id),
  metadata jsonb NOT NULL DEFAULT '{}',

  -- ‚úÖ CONSTRAINT: Un solo recurso por scope
  CHECK (
    (scope='event'  AND event_id IS NOT NULL AND course_id IS NULL AND subject_id IS NULL) OR
    (scope='course' AND course_id IS NOT NULL AND event_id IS NULL  AND subject_id IS NULL) OR
    (scope='family' AND subject_id IS NOT NULL AND event_id IS NULL AND course_id IS NULL)
  )
);

-- üöÄ √çNDICES OPTIMIZADOS
CREATE INDEX idx_access_tokens_prefix ON access_tokens(token_prefix);
CREATE INDEX idx_access_tokens_scope_event  ON access_tokens(scope, event_id);
CREATE INDEX idx_access_tokens_scope_course ON access_tokens(scope, course_id);
CREATE INDEX idx_access_tokens_scope_subject ON access_tokens(scope, subject_id);
```

**3. Logs de Auditor√≠a**
```sql
-- üÜï OBSERVABILIDAD COMPLETA
CREATE TABLE token_access_logs (
  id bigserial PRIMARY KEY,
  access_token_id uuid NOT NULL REFERENCES access_tokens(id) ON DELETE CASCADE,
  occurred_at timestamptz NOT NULL DEFAULT now(),
  ip inet,
  user_agent text,
  path text,         -- /s/:token o recurso solicitado
  action text,       -- 'list_folders' | 'list_assets' | 'download'
  ok boolean NOT NULL,
  notes text
);
CREATE INDEX idx_token_access_logs_token ON token_access_logs(access_token_id);
CREATE INDEX idx_token_access_logs_time ON token_access_logs(occurred_at DESC);
```

**4. Funciones SQL Can√≥nicas (SECURITY DEFINER)**
```sql
-- üéØ UNA SOLA FUENTE DE VERDAD: Carpetas visibles por token
CREATE OR REPLACE FUNCTION api.folders_for_token(p_token text)
RETURNS TABLE (folder_id uuid) SECURITY DEFINER AS $$
DECLARE
  v_token access_tokens%ROWTYPE;
  v_plain_prefix text := left(p_token, 10);
BEGIN
  -- üîç Lookup r√°pido por prefix + verificaci√≥n cryptogr√°fica
  SELECT * INTO v_token
  FROM access_tokens
  WHERE token_prefix = v_plain_prefix
    AND revoked_at IS NULL
    AND (expires_at IS NULL OR expires_at > now());

  IF NOT FOUND OR (digest(p_token || v_token.salt, 'sha256') <> v_token.token_hash) THEN
    RETURN; -- Token inv√°lido
  END IF;

  -- üìä Actualizar contadores de uso
  UPDATE access_tokens
     SET used_count = used_count + 1, last_used_at = now()
   WHERE id = v_token.id;

  -- üö´ Verificar l√≠mites de uso
  IF v_token.max_uses IS NOT NULL AND v_token.used_count > v_token.max_uses THEN
    RETURN; -- Token agotado
  END IF;

  -- üéØ LOGIC BY SCOPE
  -- Event: Todas las carpetas publicadas del evento
  IF v_token.scope = 'event' THEN
    RETURN QUERY
    SELECT f.id FROM folders f
     WHERE f.event_id = v_token.event_id AND f.is_published = true;

  -- Course: Solo carpetas vinculadas al curso
  ELSIF v_token.scope = 'course' THEN
    RETURN QUERY
    SELECT fc.folder_id FROM folder_courses fc
      JOIN folders f ON f.id = fc.folder_id
     WHERE fc.course_id = v_token.course_id AND f.is_published = true;

  -- Family: Carpetas de cursos donde pertenece la familia
  ELSE
    RETURN QUERY
    SELECT DISTINCT fc.folder_id
      FROM course_members cm
      JOIN folder_courses fc ON fc.course_id = cm.course_id
      JOIN folders f ON f.id = fc.folder_id
     WHERE cm.subject_id = v_token.subject_id AND f.is_published = true;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- üéØ Assets visibles por token (filtro por carpeta + familia si aplica)
CREATE OR REPLACE FUNCTION api.assets_for_token(p_token text)
RETURNS TABLE (asset_id uuid, folder_id uuid, filename text, preview_path text, original_path text)
SECURITY DEFINER AS $$
DECLARE
  v_token access_tokens%ROWTYPE;
BEGIN
  -- Validaci√≥n igual que folders_for_token (reutilizable)
  SELECT * INTO v_token FROM access_tokens
  WHERE token_prefix = left(p_token, 10)
    AND revoked_at IS NULL
    AND (expires_at IS NULL OR expires_at > now());

  IF NOT FOUND OR (digest(p_token || v_token.salt, 'sha256') <> v_token.token_hash) THEN
    RETURN;
  END IF;

  -- Event/Course: Todos los assets de carpetas accesibles
  IF v_token.scope IN ('event','course') THEN
    RETURN QUERY
    SELECT a.id, a.folder_id, a.filename, a.preview_path, a.original_path
      FROM assets a
      JOIN api.folders_for_token(p_token) tf ON tf.folder_id = a.folder_id;

  -- Family: Solo assets etiquetados con la familia
  ELSE
    RETURN QUERY
    SELECT a.id, a.folder_id, a.filename, a.preview_path, a.original_path
      FROM assets a
      JOIN asset_subjects ats ON ats.asset_id = a.id
      JOIN api.folders_for_token(p_token) tf ON tf.folder_id = a.folder_id
     WHERE ats.subject_id = v_token.subject_id;
  END IF;
END;
$$ LANGUAGE plpgsql;
```

## Arquitectura v2: 3 Niveles de Acceso Seguros

```
EVENTO (Escuela completa)
‚îú‚îÄ‚îÄ /s/E_abc123defgh ‚Üí Acceso TOTAL al evento (Director)
‚îÇ
‚îú‚îÄ‚îÄ CURSO A (5¬∫ Grado A)
‚îÇ   ‚îú‚îÄ‚îÄ /s/C_def456ijkl ‚Üí Solo curso A (Maestra A)
‚îÇ   ‚îú‚îÄ‚îÄ Carpeta: "Acto de fin de a√±o" 
‚îÇ   ‚îî‚îÄ‚îÄ Carpeta: "Excursi√≥n"
‚îÇ
‚îú‚îÄ‚îÄ CURSO B (5¬∫ Grado B)  
‚îÇ   ‚îú‚îÄ‚îÄ /s/C_ghi789mnop ‚Üí Solo curso B (Maestra B)
‚îÇ   ‚îî‚îÄ‚îÄ Carpeta: "D√≠a del estudiante"
‚îÇ
‚îî‚îÄ‚îÄ FAMILIAS dentro de cada curso
    ‚îú‚îÄ‚îÄ /s/F_jkl012qrst ‚Üí Solo fotos de Juan P√©rez
    ‚îî‚îÄ‚îÄ /s/F_mno345uvwx ‚Üí Solo fotos de Ana Garc√≠a
```

> **Rutas Unificadas:** Una sola `/s/[token]` con prefijos legibles (E_, C_, F_)

## Plan de Implementaci√≥n v2: Profesional

### FASE 1: Base de Datos - Separaci√≥n de Dominios (2h)

**1.1 Migraci√≥n: Modelo de Dominios**
```sql
-- üìÅ supabase/migrations/20250828_domain_model.sql
BEGIN;

-- üÜï CURSOS: Entidad separada y clara
CREATE TABLE courses (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id uuid NOT NULL REFERENCES events(id) ON DELETE CASCADE,
  name text NOT NULL,
  created_at timestamptz DEFAULT now(),
  UNIQUE (event_id, name)
);

-- üÜï MEMBRES√çAS: Familias pertenecen a cursos
CREATE TABLE course_members (
  course_id uuid NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  subject_id uuid NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
  PRIMARY KEY (course_id, subject_id)
);
CREATE INDEX idx_course_members_subject ON course_members(subject_id);

-- üÜï CARPETAS ‚Üî CURSOS: Relaci√≥n l√≥gica
CREATE TABLE folder_courses (
  folder_id uuid NOT NULL REFERENCES folders(id) ON DELETE CASCADE,
  course_id uuid NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  PRIMARY KEY (folder_id, course_id)
);
CREATE INDEX idx_folder_courses_course ON folder_courses(course_id);

-- üÜï ASSETS ‚Üî FAMILIAS: Etiquetado para /f/[token]
CREATE TABLE asset_subjects (
  asset_id uuid NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
  subject_id uuid NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
  PRIMARY KEY (asset_id, subject_id)
);
CREATE INDEX idx_asset_subjects_subject ON asset_subjects(subject_id);
CREATE INDEX idx_asset_subjects_asset ON asset_subjects(asset_id);

COMMIT;
```

**1.2 Migraci√≥n: Sistema de Tokens Unificado**
```sql
-- üìÅ supabase/migrations/20250828_unified_tokens.sql
BEGIN;

-- üÜï TABLA √öNICA: Todos los scopes
CREATE TABLE access_tokens (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  scope text NOT NULL CHECK (scope IN ('event','course','family')),
  
  -- Recurso seg√∫n scope (solo uno no-null)
  event_id  uuid REFERENCES events(id)   ON DELETE CASCADE,
  course_id uuid REFERENCES courses(id)  ON DELETE CASCADE,
  subject_id uuid REFERENCES subjects(id) ON DELETE CASCADE,

  -- üîê SEGURIDAD: Hash + salt
  token_hash bytea NOT NULL,
  salt bytea NOT NULL,
  token_prefix text NOT NULL,
  
  -- üéõÔ∏è CONTROL GRANULAR
  access_level text NOT NULL DEFAULT 'read_only' CHECK (access_level IN ('full','read_only')),
  can_download boolean NOT NULL DEFAULT false,
  max_uses int,
  used_count int NOT NULL DEFAULT 0,
  last_used_at timestamptz,
  expires_at timestamptz,
  revoked_at timestamptz,

  created_at timestamptz DEFAULT now(),
  created_by uuid REFERENCES auth.users(id),
  metadata jsonb NOT NULL DEFAULT '{}',

  -- ‚úÖ CONSTRAINT: Un solo recurso por scope
  CHECK (
    (scope='event'  AND event_id IS NOT NULL AND course_id IS NULL AND subject_id IS NULL) OR
    (scope='course' AND course_id IS NOT NULL AND event_id IS NULL  AND subject_id IS NULL) OR
    (scope='family' AND subject_id IS NOT NULL AND event_id IS NULL AND course_id IS NULL)
  )
);

-- üöÄ √çNDICES OPTIMIZADOS
CREATE INDEX idx_access_tokens_prefix ON access_tokens(token_prefix);
CREATE INDEX idx_access_tokens_scope_event  ON access_tokens(scope, event_id);
CREATE INDEX idx_access_tokens_scope_course ON access_tokens(scope, course_id);
CREATE INDEX idx_access_tokens_scope_subject ON access_tokens(scope, subject_id);

-- üÜï LOGS DE AUDITOR√çA
CREATE TABLE token_access_logs (
  id bigserial PRIMARY KEY,
  access_token_id uuid NOT NULL REFERENCES access_tokens(id) ON DELETE CASCADE,
  occurred_at timestamptz NOT NULL DEFAULT now(),
  ip inet,
  user_agent text,
  path text,
  action text,
  ok boolean NOT NULL,
  notes text
);
CREATE INDEX idx_token_access_logs_token ON token_access_logs(access_token_id);
CREATE INDEX idx_token_access_logs_time ON token_access_logs(occurred_at DESC);

COMMIT;
```

**1.3 Migraci√≥n: Funciones SQL Can√≥nicas**  
```sql
-- üìÅ supabase/migrations/20250828_canonical_functions.sql
BEGIN;

-- Incluir las funciones api.folders_for_token() y api.assets_for_token()
-- (Ya definidas arriba en la secci√≥n de funciones SQL)

COMMIT;
```

### FASE 2: Servicios Backend - Unificado y Seguro (2h)

**2.1 Token Generation & Validation**
```typescript
// üìÅ lib/utils/tokens.ts
import { randomBytes, createHash } from 'crypto';

function toBase62(buffer: Buffer): string {
  const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  let result = '';
  let num = BigInt('0x' + buffer.toString('hex'));
  while (num > 0) {
    result = chars[Number(num % 62n)] + result;
    num = num / 62n;
  }
  return result || '0';
}

export function generateReadableToken(prefix: 'E'|'C'|'F'): { 
  token: string; 
  prefix: string; 
  salt: Buffer; 
  hash: Buffer;
} {
  const raw = `${prefix}_${toBase62(randomBytes(16))}`;
  const salt = randomBytes(16);
  const hash = createHash('sha256').update(raw).update(salt).digest();
  
  return { 
    token: raw, 
    prefix: raw.slice(0, 10), 
    salt, 
    hash 
  };
}
```

**2.2 Unified Access Token Service**
```typescript
// üìÅ lib/services/access-token.service.ts
export class AccessTokenService {
  // üéØ Generar tokens por scope
  async createEventToken(eventId: string, options?: {
    accessLevel?: 'full'|'read_only';
    canDownload?: boolean;
    expiresAt?: Date;
    maxUses?: number;
  }) {
    const { token, prefix, salt, hash } = generateReadableToken('E');
    
    const { data } = await this.supabase
      .from('access_tokens')
      .insert({
        scope: 'event',
        event_id: eventId,
        token_hash: hash,
        salt: salt,
        token_prefix: prefix,
        access_level: options?.accessLevel || 'read_only',
        can_download: options?.canDownload || false,
        expires_at: options?.expiresAt,
        max_uses: options?.maxUses,
      })
      .select()
      .single();

    return { ...data, plainToken: token };
  }

  async createCourseToken(courseId: string, options?: {...}) {
    const { token, prefix, salt, hash } = generateReadableToken('C');
    // Similar implementation
  }

  async createFamilyToken(subjectId: string, options?: {...}) {
    const { token, prefix, salt, hash } = generateReadableToken('F');
    // Similar implementation
  }

  // üîê Validaci√≥n unificada
  async validateToken(plainToken: string): Promise<TokenValidation | null> {
    const prefix = plainToken.slice(0, 10);
    
    const { data } = await this.supabase
      .from('access_tokens')
      .select('*')
      .eq('token_prefix', prefix)
      .is('revoked_at', null)
      .single();

    if (!data) return null;

    // Verificaci√≥n cryptogr√°fica
    const expectedHash = createHash('sha256')
      .update(plainToken)
      .update(data.salt)
      .digest();

    if (!data.token_hash.equals(expectedHash)) return null;

    // Verificar expiraci√≥n y l√≠mites
    if (data.expires_at && new Date(data.expires_at) < new Date()) return null;
    if (data.max_uses && data.used_count >= data.max_uses) return null;

    return {
      tokenId: data.id,
      scope: data.scope,
      resourceId: data.event_id || data.course_id || data.subject_id,
      accessLevel: data.access_level,
      canDownload: data.can_download,
    };
  }

  // üîÑ Gesti√≥n de tokens
  async revokeToken(tokenId: string) {
    return this.supabase
      .from('access_tokens')
      .update({ revoked_at: new Date().toISOString() })
      .eq('id', tokenId);
  }

  async rotateToken(tokenId: string) {
    // Genera nuevo token manteniendo metadatos, revoca el anterior
  }

  // üìä M√©tricas de uso
  async getTokenUsage(tokenId: string) {
    return this.supabase
      .from('token_access_logs')
      .select('*')
      .eq('access_token_id', tokenId)
      .order('occurred_at', { ascending: false });
  }
}
```

**2.3 Course Management Service**
```typescript
// üìÅ lib/services/course-management.service.ts
export class CourseManagementService {
  // üè´ Gesti√≥n de cursos
  async createCourse(eventId: string, courseName: string) {
    return this.supabase
      .from('courses')
      .insert({ event_id: eventId, name: courseName })
      .select()
      .single();
  }

  // üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Gesti√≥n de membres√≠as
  async addFamilyToCourse(courseId: string, subjectId: string) {
    return this.supabase
      .from('course_members')
      .insert({ course_id: courseId, subject_id: subjectId });
  }

  // üìÅ Vinculaci√≥n carpetas-cursos  
  async linkFolderToCourses(folderId: string, courseIds: string[]) {
    const rows = courseIds.map(courseId => ({
      folder_id: folderId,
      course_id: courseId,
    }));

    return this.supabase
      .from('folder_courses')
      .upsert(rows);
  }

  // üè∑Ô∏è Etiquetado assets-familias
  async tagAssetsWithFamily(assetIds: string[], subjectId: string) {
    const rows = assetIds.map(assetId => ({
      asset_id: assetId,
      subject_id: subjectId,
    }));

    return this.supabase
      .from('asset_subjects')
      .upsert(rows);
  }
}
```

### FASE 3: Ruta Unificada - M√°s Simple y Segura (1.5h)

**3.1 Ruta Unificada: /s/[token]**
```typescript
// üìÅ app/(share)/s/[token]/page.tsx
import { notFound } from 'next/navigation';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export default async function SharePage({ params }: { params: { token: string } }) {
  const supabase = await createServerSupabaseClient();
  
  // üéØ Usar funciones SQL can√≥nicas
  const [foldersResult, assetsResult] = await Promise.all([
    supabase.rpc('api.folders_for_token', { p_token: params.token }),
    supabase.rpc('api.assets_for_token', { p_token: params.token })
  ]);

  if (!foldersResult.data?.length) return notFound();

  // üìä Log del acceso (auditor√≠a)
  await logTokenAccess(params.token, 'list_folders', req);

  return (
    <UnifiedShareGallery 
      folders={foldersResult.data}
      assets={assetsResult.data}
      token={params.token}
    />
  );
}

// üîê Middleware de seguridad
export async function middleware(request: NextRequest) {
  const response = NextResponse.next();
  
  // üö´ Headers de seguridad
  response.headers.set('X-Robots-Tag', 'noindex, nofollow');
  response.headers.set('Referrer-Policy', 'no-referrer');
  response.headers.set('Cache-Control', 'private, max-age=300');
  
  // üõ°Ô∏è Rate limiting por IP
  const ip = request.ip || 'unknown';
  const isRateLimited = await checkRateLimit(ip);
  
  if (isRateLimited) {
    return new Response('Too Many Requests', { status: 429 });
  }
  
  return response;
}
```

**3.2 Componente Unificado de Galer√≠a**
```typescript
// üìÅ components/share/UnifiedShareGallery.tsx
interface UnifiedShareGalleryProps {
  folders: Array<{ folder_id: string };
  assets: Array<{ asset_id: string; folder_id: string; filename: string; preview_path: string };
  token: string;
}

export function UnifiedShareGallery({ folders, assets, token }: UnifiedShareGalleryProps) {
  const scope = token.startsWith('E_') ? 'event' : 
               token.startsWith('C_') ? 'course' : 'family';
  
  return (
    <div className="min-h-screen bg-gray-50">
      {/* üé® Header contextual por scope */}
      <ShareHeader scope={scope} />
      
      {/* üìÅ Navegaci√≥n de carpetas */}
      <FolderNavigation folders={folders} />
      
      {/* üñºÔ∏è Galer√≠a de assets con lazy loading */}
      <VirtualizedAssetGrid 
        assets={assets}
        onDownload={(assetId) => handleDownload(assetId, token)}
      />
      
      {/* üîí Footer con info de token (sin exponer detalles) */}
      <ShareFooter />
    </div>
  );
}

async function handleDownload(assetId: string, token: string) {
  // ‚úÖ Verificar can_download antes de permitir descarga
  const response = await fetch(`/api/share/download/${assetId}?token=${token}`);
  
  if (!response.ok) {
    toast.error('Descarga no permitida');
    return;
  }
  
  // Stream del archivo
  const blob = await response.blob();
  const url = window.URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `foto-${assetId}.jpg`;
  document.body.appendChild(a);
  a.click();
  
  window.URL.revokeObjectURL(url);
  document.body.removeChild(a);
}
```

**3.3 API de Descarga Segura**
```typescript  
// üìÅ app/api/share/download/[assetId]/route.ts
export async function GET(
  request: NextRequest,
  { params }: { params: { assetId: string } }
) {
  const token = request.nextUrl.searchParams.get('token');
  if (!token) return new Response('Token required', { status: 401 });

  // üîê Validar token y can_download
  const tokenService = new AccessTokenService();
  const validation = await tokenService.validateToken(token);
  
  if (!validation || !validation.canDownload) {
    return new Response('Download not allowed', { status: 403 });
  }

  // üìä Log de descarga
  await logTokenAccess(token, 'download', request, params.assetId);

  // üéØ Verificar que el asset es accesible por el token
  const supabase = await createServerSupabaseServiceClient();
  const { data: assets } = await supabase.rpc('api.assets_for_token', { 
    p_token: token 
  });

  const asset = assets?.find(a => a.asset_id === params.assetId);
  if (!asset) return new Response('Asset not found', { status: 404 });

  // üì¶ Stream del archivo desde Supabase Storage
  const { data } = await supabase.storage
    .from('photo-private')
    .download(asset.original_path);

  if (!data) return new Response('File not found', { status: 404 });

  return new Response(data, {
    headers: {
      'Content-Type': 'image/jpeg',
      'Content-Disposition': `attachment; filename="foto-${params.assetId}.jpg"`,
    },
  });
}
```

### FASE 4: APIs Admin Unificadas (1.5h)

**4.1 API Unificada de Tokens**
```typescript
// üìÅ app/api/admin/access-tokens/route.ts
export async function POST(request: NextRequest) {
  const { scope, resourceId, accessLevel, canDownload, maxUses, expiresAt } = await request.json();
  
  const tokenService = new AccessTokenService();
  
  switch (scope) {
    case 'event':
      return tokenService.createEventToken(resourceId, { accessLevel, canDownload, maxUses, expiresAt });
    case 'course':
      return tokenService.createCourseToken(resourceId, { accessLevel, canDownload, maxUses, expiresAt });
    case 'family':
      return tokenService.createFamilyToken(resourceId, { accessLevel, canDownload, maxUses, expiresAt });
  }
}

// GET /api/admin/access-tokens?scope=event&resourceId=123
export async function GET(request: NextRequest) {
  const { searchParams } = request.nextUrl;
  const scope = searchParams.get('scope');
  const resourceId = searchParams.get('resourceId');
  
  // Listar tokens por scope y recurso
}

// üìÅ app/api/admin/access-tokens/[tokenId]/route.ts
export async function DELETE(request: NextRequest, { params }: { params: { tokenId: string } }) {
  const tokenService = new AccessTokenService();
  return tokenService.revokeToken(params.tokenId);
}

export async function PUT(request: NextRequest, { params }: { params: { tokenId: string } }) {
  const { action } = await request.json();
  
  const tokenService = new AccessTokenService();
  
  if (action === 'rotate') {
    return tokenService.rotateToken(params.tokenId);
  }
  
  // Otros updates...
}
```

**4.2 API de Course Management**  
```typescript
// üìÅ app/api/admin/courses/route.ts
export async function POST(request: NextRequest) {
  const { eventId, courseName } = await request.json();
  
  const courseService = new CourseManagementService();
  return courseService.createCourse(eventId, courseName);
}

// üìÅ app/api/admin/folders/[id]/courses/route.ts
export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const { courseIds } = await request.json();
  
  const courseService = new CourseManagementService();
  return courseService.linkFolderToCourses(params.id, courseIds);
}

// üìÅ app/api/admin/assets/tag/route.ts
export async function POST(request: NextRequest) {
  const { assetIds, subjectId } = await request.json();
  
  const courseService = new CourseManagementService();
  return courseService.tagAssetsWithFamily(assetIds, subjectId);
}
```

### FASE 5: UI Admin Unificada - Con Vista Previa (2h)

**5.1 Gestor Unificado de Tokens**
```typescript
// üìÅ components/admin/UnifiedAccessTokenManager.tsx
export function UnifiedAccessTokenManager({ scope, resourceId }: {
  scope: 'event' | 'course' | 'family';
  resourceId: string;
}) {
  const [tokens, setTokens] = useState([]);
  const [previewToken, setPreviewToken] = useState<string | null>(null);

  return (
    <div className="space-y-6">
      {/* üéõÔ∏è Crear Token */}
      <CreateTokenForm 
        scope={scope}
        resourceId={resourceId}
        onTokenCreated={(token) => setTokens([...tokens, token])}
      />

      {/* üìä Lista de Tokens Activos */}
      <TokenList 
        tokens={tokens}
        onRevoke={handleRevoke}
        onRotate={handleRotate}
        onPreview={(token) => setPreviewToken(token)}
      />

      {/* üîç Vista Previa "Ver Como" */}
      {previewToken && (
        <TokenPreviewModal 
          token={previewToken}
          onClose={() => setPreviewToken(null)}
        />
      )}

      {/* üì± QR Code Generator */}
      <QRCodeGenerator tokens={tokens} />
    </div>
  );
}

// Vista previa en sandbox
function TokenPreviewModal({ token }: { token: string }) {
  return (
    <Dialog>
      <DialogContent className="max-w-4xl">
        <DialogHeader>
          <DialogTitle>Vista Previa: {token.slice(0, 12)}...</DialogTitle>
        </DialogHeader>
        
        {/* üéØ Iframe sandbox con el token */}
        <iframe 
          src={`/s/${token}?preview=true`}
          className="w-full h-96 border rounded"
          sandbox="allow-same-origin allow-scripts"
        />
        
        <div className="text-sm text-gray-500">
          Esto es exactamente lo que ver√°n los usuarios con este token.
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

**5.2 Course & Folder Linker**  
```typescript
// üìÅ components/admin/CourseLinker.tsx
export function CourseLinker({ folderId }: { folderId: string }) {
  const [courses, setCourses] = useState([]);
  const [linkedCourses, setLinkedCourses] = useState([]);

  return (
    <div className="space-y-4">
      <h3>Vincular Carpeta con Cursos</h3>
      
      {/* ‚úÖ Checkboxes por curso */}
      {courses.map(course => (
        <div key={course.id} className="flex items-center space-x-2">
          <Checkbox 
            checked={linkedCourses.includes(course.id)}
            onChange={(checked) => handleLinkChange(course.id, checked)}
          />
          <label>{course.name}</label>
          
          {/* üë• Preview de familias en el curso */}
          <Badge variant="outline">
            {course.family_count} familias
          </Badge>
        </div>
      ))}

      {/* üîÑ Bulk Operations */}
      <div className="flex gap-2">
        <Button onClick={handleSelectAll}>Seleccionar Todo</Button>
        <Button onClick={handleSelectNone} variant="outline">Deseleccionar</Button>
        <Button onClick={handleApplyChanges} variant="default">Aplicar Cambios</Button>
      </div>
    </div>
  );
}
```

## ‚ö° Performance & Migraci√≥n sin Downtime

### **Optimizaciones de Performance**
```sql
-- üöÄ √çndices covering para consultas frecuentes
CREATE INDEX idx_assets_folder_cover ON assets(folder_id, id) 
INCLUDE (preview_path, filename, original_path);

-- üìä Vista materializada opcional para alta escala
CREATE MATERIALIZED VIEW mv_course_folder_assets AS
SELECT fc.course_id, fc.folder_id, a.id as asset_id, a.preview_path
FROM folder_courses fc
JOIN assets a ON a.folder_id = fc.folder_id
WHERE a.status = 'ready';

CREATE INDEX idx_mv_course_folder_assets ON mv_course_folder_assets(course_id);
```

### **Migraci√≥n Sin Downtime**
```sql
-- üìÅ supabase/migrations/20250828_migration_strategy.sql
BEGIN;

-- 1Ô∏è‚É£ Crear tablas nuevas (sin afectar tr√°fico actual)
-- (Ya definidas arriba)

-- 2Ô∏è‚É£ Backfill gradual de datos existentes
-- Migrar subjects actuales ‚Üí courses + course_members
INSERT INTO courses (event_id, name) 
SELECT DISTINCT event_id, COALESCE(grade || ' ' || section, 'Sin Curso')
FROM subjects 
WHERE grade IS NOT NULL;

-- Vincular familias con cursos basado en grade/section
INSERT INTO course_members (course_id, subject_id)
SELECT c.id, s.id 
FROM subjects s
JOIN courses c ON c.event_id = s.event_id 
AND c.name = COALESCE(s.grade || ' ' || s.section, 'Sin Curso');

-- 3Ô∏è‚É£ Mantener subject_tokens funcionando (retrocompatibilidad)
-- Los tokens familiares actuales siguen funcionando via /f/[token]

-- 4Ô∏è‚É£ Nuevos tokens van a access_tokens
-- El admin UI permite crear tokens nuevos en paralelo

COMMIT;
```

## üéØ **Conclusi√≥n - Plan v2 Mejorado**

### **Beneficios vs. Plan Original:**
- ‚úÖ **Separaci√≥n de dominios** ‚Üí Cursos ‚â† Familias (claridad conceptual)
- ‚úÖ **Seguridad real** ‚Üí Hash+salt vs texto plano (nunca m√°s tokens expuestos)  
- ‚úÖ **Observabilidad completa** ‚Üí Logs, m√©tricas, auditor√≠a (control total)
- ‚úÖ **Performance optimizada** ‚Üí Funciones SQL, √≠ndices covering (escalable)
- ‚úÖ **UI con vista previa** ‚Üí "Ver como" sandbox (UX superior)

### **Timeline Actualizado:**
| Fase | Tiempo | Descripci√≥n |
|------|--------|-------------|
| 1 | 2h | Migraciones DB (dominios + tokens unificados) |
| 2 | 2h | Servicios backend (AccessTokenService + CourseManagement) |
| 3 | 1.5h | Ruta unificada /s/[token] + middleware seguridad |
| 4 | 1.5h | APIs admin unificadas |
| 5 | 2h | UI admin con vista previa y QR |
| **TOTAL** | **9h** | **Sistema v2 completo** |

### **Migraci√≥n Segura:**
1. ‚úÖ **Retrocompatibilidad completa** ‚Üí `/f/[token]` sigue funcionando
2. ‚úÖ **Testing en paralelo** ‚Üí Nuevos tokens conviven con actuales  
3. ‚úÖ **Rollback simple** ‚Üí Tablas nuevas son opcionales
4. ‚úÖ **Zero downtime** ‚Üí Migraci√≥n gradual sin interrupciones

**¬øProcedemos con la implementaci√≥n del Plan v2 Mejorado?**

## Casos de Uso y Flujos

### Caso 1: Director quiere dar acceso completo al evento
```
1. Admin ‚Üí /admin/events/[id]/tokens
2. Click "Generar Token Evento Completo" 
3. Sistema genera: /e/abc123
4. Director comparte link ‚Üí Padres ven TODO el evento
```

### Caso 2: Maestra quiere acceso solo a su curso  
```
1. Admin ‚Üí /admin/events/[id] ‚Üí Curso "5¬∫ A"
2. Click "Generar Token de Curso"
3. Sistema genera: /c/def456  
4. Maestra comparte ‚Üí Solo ven fotos de 5¬∫ A
```

### Caso 3: Familia quiere acceso individual
```
1. (Ya funciona) ‚Üí /f/jkl012
2. Solo ven fotos de sus hijos
```

### Caso 4: Gesti√≥n de carpetas por curso
```
1. Admin sube fotos del "Acto de fin de a√±o"
2. En publish ‚Üí Vincula carpeta con "5¬∫ A" y "5¬∫ B"
3. Token /c/curso-5a ‚Üí Solo ve carpetas de 5¬∫ A
4. Token /e/evento ‚Üí Ve todas las carpetas
```

## Beneficios del Sistema Jer√°rquico

### Escalabilidad  
- ‚úÖ **Antes**: 100 carpetas = 100 links individuales
- ‚úÖ **Despu√©s**: 1 link de evento = acceso a 100 carpetas

### Flexibilidad de Acceso
- üéØ **Evento completo**: Director, coordinadores  
- üéØ **Por curso**: Maestras, padres delegados
- üéØ **Por familia**: Padres individuales

### Gesti√≥n Simplificada
- ‚úÖ Menos tokens que gestionar
- ‚úÖ Permisos m√°s claros y organizados
- ‚úÖ Bulk operations m√°s eficientes

### Performance Mejorada
- ‚úÖ Caching por nivel de jerarqu√≠a
- ‚úÖ Lazy loading de carpetas
- ‚úÖ Filtros m√°s eficientes en base de datos

## Timeline de Implementaci√≥n

| Fase | Tiempo | Descripci√≥n |
|------|--------|-------------|
| 1 | 2h | Migraciones DB + RLS policies |
| 2 | 3h | Servicios backend (event/course tokens) |
| 3 | 2h | Rutas /e/[token] y /c/[token] |
| 4 | 2h | APIs de gesti√≥n admin |
| 5 | 3h | Interface admin para tokens |
| **TOTAL** | **12h** | **Sistema completo funcional** |

## Migraci√≥n Sin Downtime

1. **Retrocompatibilidad**: `/f/[token]` sigue funcionando
2. **Migraci√≥n gradual**: Event/course tokens se agregan sin afectar familia tokens  
3. **Testing**: Crear tokens de prueba antes del rollout
4. **Rollback**: Todas las tablas nuevas son opcionales

## Consideraciones de Seguridad

### Tokens de Evento (Alto Acceso)
- ‚úÖ Expiraci√≥n: 90 d√≠as (m√°s larga)
- ‚úÖ Rotaci√≥n: Manual por admin
- ‚úÖ Auditor√≠a: Log de todos los accesos

### Tokens de Curso (Acceso Medio)  
- ‚úÖ Expiraci√≥n: 60 d√≠as
- ‚úÖ Acceso de solo lectura por defecto
- ‚úÖ Vinculaci√≥n espec√≠fica folder-subject

### Tokens de Familia (Acceso Restringido)
- ‚úÖ Expiraci√≥n: 30 d√≠as (actual)
- ‚úÖ Solo sus fotos familiares
- ‚úÖ Sistema actual mantiene funcionalidad

## Pr√≥ximos Pasos Inmediatos

1. **Validar plan** con el equipo/usuario
2. **Crear branch**: `feat/hierarchical-access-system`  
3. **Implementar Fase 1**: Migraciones de base de datos
4. **Testing**: Verificar que no rompe funcionalidad actual
5. **Implementar por fases**: 1‚Üí2‚Üí3‚Üí4‚Üí5

---

**Conclusi√≥n**: Tenemos 80% de la infraestructura lista. El sistema jer√°rquico propuesto es **factible, escalable y mantiene retrocompatibilidad**. La implementaci√≥n completa tomar√≠a ~12 horas de desarrollo en 5 fases bien definidas.