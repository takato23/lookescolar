diff --git a/app/api/store/[token]/route.ts b/app/api/store/[token]/route.ts
index de520eb..ef1e1f1 100644
--- a/app/api/store/[token]/route.ts
+++ b/app/api/store/[token]/route.ts
@@ -8,6 +8,12 @@ import { NextRequest, NextResponse } from 'next/server';
 import { createServerSupabaseServiceClient } from '@/lib/supabase/server';
 import { z } from 'zod';
 import { validateShareTokenPassword } from '@/lib/middleware/password-validation.middleware';
+import { photoClassificationService } from '@/lib/services/photo-classification.service';
+import {
+  galleryService,
+  GalleryServiceError,
+  type GalleryResult,
+} from '@/lib/services/gallery.service';
 
 const QuerySchema = z.object({
   include_assets: z
@@ -40,8 +46,8 @@ export async function GET(
     const passwordFromHeader = request.headers.get('X-Store-Password');
     const passwordToValidate = password || passwordFromHeader;
 
-    // Validar formato del token
-    if (!token || token.length < 8 || !/^[a-z0-9]+$/.test(token)) {
+    // Validar formato del token (permitir guiones para tokens de prueba)
+    if (!token || token.length < 8 || !/^[a-z0-9-]+$/.test(token)) {
       return NextResponse.json(
         { error: 'Invalid store token format' },
         { status: 400 }
@@ -139,14 +145,9 @@ export async function GET(
     
     // Si no se encontró en share_tokens, buscar en folders (tokens de 16 caracteres)
     if (!storeData) {
-      // Check if we need to use the new navigation RPC
-      const rpcName = folder_id !== undefined ? 'get_folder_navigation_data' : 'get_store_data';
-      const rpcParams = folder_id !== undefined
-        ? { p_token: token, p_folder_id: folder_id || null }
-        : { p_token: token };
-
+      // Usar get_store_data para tokens de folder
       const { data: folderData, error: storeError } = await supabase
-        .rpc(rpcName, rpcParams)
+        .rpc('get_store_data', { p_token: token })
         .single();
 
       if (storeError || !folderData) {
@@ -160,10 +161,58 @@ export async function GET(
     }
 
     let assets = [];
-    let pagination = null;
+    let pagination: any = null;
+    let galleryPayload: GalleryResult | null = null;
 
-    // Incluir assets si se solicita
     if (include_assets) {
+      try {
+        const pageFromOffset = Math.floor(offset / limit) + 1;
+        galleryPayload = await galleryService.getGallery({
+          token,
+          page: pageFromOffset,
+          limit,
+          ipAddress: clientIp,
+          userAgent: request.headers.get('user-agent') ?? undefined,
+          includeCatalog: true,
+          skipRateLimit: true,
+        });
+
+        assets = galleryPayload.items.map((item) => ({
+          id: item.id,
+          filename: item.filename,
+          preview_url: item.previewUrl ?? item.signedUrl ?? null,
+          watermark_url: item.signedUrl ?? null,
+          file_size: item.size ?? 0,
+          created_at: item.createdAt ?? new Date().toISOString(),
+          storage_path: item.storagePath ?? null,
+          status: 'ready',
+          is_group_photo: item.type === 'group',
+        }));
+
+        pagination = {
+          limit,
+          offset,
+          total: galleryPayload.pagination.total,
+          hasMore: galleryPayload.pagination.hasMore,
+          page: galleryPayload.pagination.page,
+          total_pages: galleryPayload.pagination.totalPages,
+        };
+      } catch (error) {
+        if (error instanceof GalleryServiceError) {
+          console.warn('Unified gallery fallback (store route)', {
+            token,
+            code: error.code,
+            message: error.message,
+          });
+        } else {
+          console.error('Unified gallery unexpected error', error);
+        }
+        galleryPayload = null;
+      }
+    }
+
+    // Incluir assets legacy si no está disponible la galería unificada
+    if (include_assets && !galleryPayload) {
       // Intentar primero con assets, luego con photos como fallback
       let assetsData: any = null;
       let assetsError: any = null;
@@ -175,7 +224,7 @@ export async function GET(
           // Primero intentar con assets usando los IDs específicos
           const assetsResult = await supabase
             .from('assets')
-            .select('*', { count: 'exact' })
+            .select('*, photos!left(metadata, file_size, created_at)', { count: 'exact' })
             .in('id', storeData.selected_photo_ids)
             .eq('status', 'ready')
             .order('created_at', { ascending: false })
@@ -202,7 +251,7 @@ export async function GET(
           // Si no hay photo_ids específicos, buscar por folder_id
           const assetsResult = await supabase
             .from('assets')
-            .select('*', { count: 'exact' })
+            .select('*, photos!left(metadata, file_size, created_at)', { count: 'exact' })
             .eq('folder_id', storeData.folder_id)
             .eq('status', 'ready')
             .order('created_at', { ascending: false })
@@ -245,12 +294,81 @@ export async function GET(
           const buildPublicUrl = (path?: string | null) => {
             if (!path) return null;
             if (path.startsWith('http')) return path;
-            // Extract just the filename or relative path
+
+            // Handle different path formats
             const normalized = path.replace(/^\/+/, '');
-            // Use our public preview endpoint
-            return `/api/public/preview/${normalized}`;
+
+            // If path already includes 'previews/' or 'watermarks/', use it directly
+            if (normalized.includes('previews/') || normalized.includes('watermarks/')) {
+              return `/api/public/preview/${normalized}`;
+            }
+
+            // For storage paths, assume they're in previews directory
+            return `/api/public/preview/previews/${normalized}`;
           };
 
+          // Get photo assignments in batch for better performance
+          const photoIds = assetsData.map(item => item.id);
+
+          // Get all photo assignments at once
+          const { data: photoAssignments } = await supabase
+            .from('photo_students')
+            .select('photo_id, student_id')
+            .in('photo_id', photoIds);
+
+          const { data: courseAssignments } = await supabase
+            .from('photo_courses')
+            .select('photo_id, course_id')
+            .in('photo_id', photoIds);
+
+          const { data: legacyAssignments } = await supabase
+            .from('photo_assignments')
+            .select('photo_id, subject_id')
+            .in('photo_id', photoIds);
+
+          // Create lookup maps for efficient checking
+          const studentPhotoMap = new Set(photoAssignments?.map(pa => pa.photo_id) || []);
+          const coursePhotoMap = new Set(courseAssignments?.map(ca => ca.photo_id) || []);
+          const legacyPhotoMap = new Set(legacyAssignments?.map(la => la.photo_id) || []);
+
+          // Get unassigned photos for AI classification
+          const unassignedPhotos = assetsData.filter(item =>
+            !coursePhotoMap.has(item.id) &&
+            !studentPhotoMap.has(item.id) &&
+            !legacyPhotoMap.has(item.id)
+          );
+
+          // Classify unassigned photos
+          const classificationPromises = unassignedPhotos.map(async (item) => {
+            try {
+              const classification = await photoClassificationService.classifyPhoto(item.id);
+              return {
+                id: item.id,
+                isGroupPhoto: classification.isGroupPhoto && classification.confidence > 0.7,
+                confidence: classification.confidence,
+                reason: classification.reason
+              };
+            } catch (error) {
+              console.error(`Error classifying photo ${item.id}:`, error);
+              return {
+                id: item.id,
+                isGroupPhoto: false,
+                confidence: 0,
+                reason: 'Classification failed'
+              };
+            }
+          });
+
+          const classifications = await Promise.all(classificationPromises);
+
+          // Create classification map
+          const classificationMap = new Map(classifications.map(c => [c.id, c]));
+
+          // Log classifications
+          classifications.forEach(({ id, isGroupPhoto, confidence, reason }) => {
+            console.log(`AI Classification for ${id}: ${isGroupPhoto ? 'GROUP' : 'INDIVIDUAL'} (${confidence.toFixed(2)} confidence) - ${reason}`);
+          });
+
           assets = assetsData.map((item: any) => {
             // Try different URL patterns for watermarked previews
             let previewUrl =
@@ -259,18 +377,42 @@ export async function GET(
               buildPublicUrl(item.watermark_path) ||
               buildPublicUrl(item.watermark_url) ||
               buildPublicUrl(item.storage_path);
-            
+
             // If still no URL and we have storage_path, use it through our preview endpoint
             if (!previewUrl && item.storage_path) {
-              const path = item.storage_path.replace(/^\/+/, '');
-              previewUrl = `/api/public/preview/${path}`;
+              const storagePath = item.storage_path.replace(/^\/+/, '');
+
+              // If storage path already includes previews/ or watermarks/, use it directly
+              if (storagePath.includes('previews/') || storagePath.includes('watermarks/')) {
+                previewUrl = `/api/public/preview/${storagePath}`;
+              } else {
+                // Otherwise, assume it's in previews directory
+                previewUrl = `/api/public/preview/previews/${storagePath}`;
+              }
             }
-            
+
             const wmUrl =
-              buildPublicUrl(item.watermark_path) || 
+              buildPublicUrl(item.watermark_path) ||
               buildPublicUrl(item.watermark_url) ||
               previewUrl;
 
+            // Determine if this is a group photo using the pre-fetched data
+            let isGroupPhoto = false;
+
+            if (coursePhotoMap.has(item.id)) {
+              // Photo is assigned to a course → group photo
+              isGroupPhoto = true;
+            } else if (studentPhotoMap.has(item.id) || legacyPhotoMap.has(item.id)) {
+              // Photo is assigned to students → individual photo
+              isGroupPhoto = false;
+            } else {
+              // Photo is not assigned anywhere - use AI classification
+              const classification = classificationMap.get(item.id);
+              if (classification) {
+                isGroupPhoto = classification.isGroupPhoto;
+              }
+            }
+
             return {
               id: item.id,
               filename:
@@ -280,31 +422,35 @@ export async function GET(
                 'foto',
               preview_url: previewUrl,
               watermark_url: wmUrl,
-              file_size: item.file_size || item.file_size_bytes || 0,
-              created_at: item.created_at || item.uploaded_at || item.created_at,
+              file_size: item.photos?.file_size || item.file_size || item.file_size_bytes || 0,
+              created_at: item.photos?.created_at || item.created_at || item.uploaded_at || new Date().toISOString(),
               storage_path: item.storage_path || null,
               status: item.status || 'ready',
+              is_group_photo: isGroupPhoto,
             };
           });
         } else {
           assets = [];
         }
 
+        const totalItems = count || 0;
         pagination = {
           limit,
           offset,
-          total: count || 0,
-          hasMore: count ? count > offset + limit : false,
+          total: totalItems,
+          hasMore: totalItems ? totalItems > offset + limit : false,
+          page: Math.floor(offset / limit) + 1,
+          total_pages: totalItems ? Math.max(1, Math.ceil(totalItems / limit)) : 1,
         };
       }
     }
 
     // Formatear respuesta con información de jerarquía
-    const storeResponse = {
-      store: {
-        token,
-        name: storeData.folder_name,
-        folder_path: storeData.folder_path || storeData.folder_name,
+  const storeResponse = {
+    store: {
+      token,
+      name: storeData.folder_name,
+      folder_path: storeData.folder_path || storeData.folder_name,
         parent_id: storeData.parent_id || null,
         parent_name: storeData.parent_name || null,
         depth: storeData.depth || 0,
@@ -319,10 +465,15 @@ export async function GET(
       event: {
         id: storeData.event_id,
         name: storeData.event_name,
-        date: storeData.event_date,
-      },
-      assets: include_assets ? assets : undefined,
-      pagination: include_assets ? pagination : undefined,
+      date: storeData.event_date,
+    },
+    assets: include_assets ? assets : undefined,
+    pagination: include_assets ? pagination : undefined,
+    gallery: include_assets ? galleryPayload ?? undefined : undefined,
+    gallery_rate_limit:
+      include_assets && galleryPayload ? galleryPayload.rateLimit : undefined,
+    gallery_catalog:
+      include_assets && galleryPayload ? galleryPayload.catalog ?? null : undefined,
     };
 
     // Headers para cache público
