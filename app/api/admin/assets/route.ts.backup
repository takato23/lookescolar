/**
 * Ultra-Optimized Assets API - Minimal Egress Usage
 * GET: List assets with efficient pagination
 * POST: Upload asset with processing queue
 */

import { NextRequest, NextResponse } from 'next/server';
import { withAuth } from '@/lib/middleware/auth.middleware';
import { RateLimitMiddleware } from '@/lib/middleware/rate-limit.middleware';
import { createServerSupabaseServiceClient } from '@/lib/supabase/server';
import { z } from 'zod';
import { logger } from '@/lib/utils/logger';
import { nanoid } from 'nanoid';
import crypto from 'crypto';

// Generate unique request ID for tracking
function generateRequestId(): string {
  return `req_${crypto.randomBytes(8).toString('hex')}`;
}

// Generate unique error ID for 500 responses
function generateErrorId(): string {
  return `err_${crypto.randomBytes(6).toString('hex')}`;
}

// Updated validation schema with required fields
const assetQuerySchema = z.object({
  event_id: z.string().uuid().optional(),
  folder_id: z.string().uuid().optional(),
  include_children: z.coerce.boolean().default(false),
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(200).default(50),
  status: z.enum(['pending', 'processing', 'ready', 'error']).nullish(),
  q: z.string().trim().min(1).max(100).nullish(),
  min_size: z.coerce.number().min(0).nullish(),
  max_size: z.coerce.number().min(0).nullish(),
  start_date: z.coerce.date().nullish(),
  end_date: z.coerce.date().nullish(),
});

const uploadAssetSchema = z.object({
  folder_id: z.string().uuid(),
  filename: z.string()
    .min(1, 'Filename required')
    .max(255, 'Filename too long')
    .regex(/\.(jpg|jpeg|png|webp)$/i, 'Invalid image format'),
  file_size: z.number().min(1).max(10 * 1024 * 1024), // Max 10MB
  checksum: z.string().length(64, 'Invalid checksum'), // SHA-256
  mime_type: z.string().regex(/^image\/(jpg|jpeg|png|webp)$/, 'Invalid mime type'),
});

// Types for minimal data transfer
interface AssetListItem {
  id: string;
  filename: string;
  preview_path: string | null;
  file_size: number;
  created_at: string;
}

interface UploadAssetResponse {
  id: string;
  upload_url: string;
  expires_at: string;
}

/**
 * GET /api/admin/assets
 * List assets with CTE recursive support and structured logging
 */
async function handleGET(request: NextRequest) {
  const requestId = generateRequestId();
  
  try {
    logger.info('Assets API request started', { requestId, url: request.url });
    
    // Validate environment variables
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
      const errorId = generateErrorId();
      logger.error('Missing Supabase environment variables', { requestId, errorId });
      return NextResponse.json(
        { errorId, message: 'Internal server error' },
        { status: 500 }
      );
    }

    // Parse and validate query params
    const url = new URL(request.url);
    let queryParams;
    try {
      queryParams = assetQuerySchema.parse({
        event_id: url.searchParams.get('event_id') || undefined,
        folder_id: url.searchParams.get('folder_id') || undefined,
        include_children: url.searchParams.get('include_children'),
        page: url.searchParams.get('page'),
        limit: url.searchParams.get('limit'),
        status: url.searchParams.get('status'),
        q: url.searchParams.get('q'),
        min_size: url.searchParams.get('min_size'),
        max_size: url.searchParams.get('max_size'),
        start_date: url.searchParams.get('start_date'),
        end_date: url.searchParams.get('end_date'),
      });
    } catch (validationError) {
      logger.warn('Invalid asset query parameters', { 
        requestId, 
        error: validationError,
        rawParams: Object.fromEntries(url.searchParams.entries())
      });
      return NextResponse.json(
        { 
          success: false, 
          error: 'Invalid query parameters',
          details: validationError instanceof z.ZodError ? validationError.errors : undefined
        },
        { status: 400 }
      );
    }
    
    // Calculate offset from page
    const offset = (queryParams.page - 1) * queryParams.limit;
    
    logger.info('Normalized query parameters', { 
      requestId, 
      params: { ...queryParams, offset }
    });

    // Require either folder_id or event_id
    if (!queryParams.folder_id && !queryParams.event_id) {
      logger.warn('Missing required filter parameter', { requestId });
      return NextResponse.json(
        { 
          success: false, 
          error: 'Either folder_id or event_id is required',
          details: [{ path: ['folder_id', 'event_id'], message: 'At least one filter required' }]
        },
        { status: 400 }
      );
    }

    const supabaseAdmin = await createServerSupabaseServiceClient();
    let assets, error;
    
    try {
      // Build CTE recursive query for include_children
      if (queryParams.folder_id && queryParams.include_children) {
        logger.info('Using CTE recursive query for folder hierarchy', { requestId, folderId: queryParams.folder_id });
        
        const cteQuery = `
          WITH RECURSIVE folder_tree AS (
            SELECT id FROM folders WHERE id = $1
            UNION ALL
            SELECT f.id 
            FROM folders f 
            JOIN folder_tree ft ON f.parent_folder_id = ft.id
          )
          SELECT a.id, a.filename, a.preview_path, a.file_size, a.created_at
          FROM assets a
          WHERE a.folder_id IN (SELECT id FROM folder_tree)
            AND a.status = COALESCE($4, a.status)
            AND ($5::text IS NULL OR a.filename ILIKE $5)
            AND ($6::int IS NULL OR a.file_size >= $6)
            AND ($7::int IS NULL OR a.file_size <= $7)
            AND ($8::timestamptz IS NULL OR a.created_at >= $8)
            AND ($9::timestamptz IS NULL OR a.created_at <= $9)
          ORDER BY a.created_at DESC
          LIMIT $2 OFFSET $3
        `;
        
        const { data, error: cteError } = await supabaseAdmin
          .from('assets')
          .select('*')
          .filter('id', 'eq', 'never-match') // Fallback to raw SQL
          .limit(1);
          
        // Execute raw SQL since Supabase client doesn't support CTE directly
        try {
          const { data: rawData, error: rawError } = await supabaseAdmin.rpc('exec_sql', {
            query: cteQuery,
            params: [
              queryParams.folder_id,
              queryParams.limit, 
              offset,
              queryParams.status,
              queryParams.q ? `%${queryParams.q}%` : null,
              queryParams.min_size,
              queryParams.max_size,
              queryParams.start_date?.toISOString(),
              queryParams.end_date?.toISOString()
            ]
          });
          
          if (!rawError && rawData) {
            assets = rawData;
          } else {
            throw new Error(`CTE query failed: ${rawError?.message}`);
          }
        } catch (cteErr) {
          logger.warn('CTE recursive query failed, falling back to manual resolution', { requestId, error: cteErr });
          // Fallback to manual folder resolution
          const folderIds = await resolveFolderHierarchy(supabaseAdmin, queryParams.folder_id);
          assets = await queryAssetsWithFolderIds(supabaseAdmin, folderIds, queryParams, offset);
        }
      } else if (queryParams.folder_id) {
        // Simple folder query without children
        logger.info('Querying assets for single folder', { requestId, folderId: queryParams.folder_id });
        assets = await queryAssetsWithFolderIds(supabaseAdmin, [queryParams.folder_id], queryParams, offset);
      } else if (queryParams.event_id) {
        // Event-based query (ignore include_children for events)
        logger.info('Querying assets for event', { requestId, eventId: queryParams.event_id });
        assets = await queryAssetsByEvent(supabaseAdmin, queryParams.event_id, queryParams, offset);
      }
      if (!queryParams.q) {
        // Try RPC first (if it exists)
        const rpcResult = await supabaseAdmin
          .rpc('get_folder_assets', {
            p_folder_id: queryParams.folder_id,
            p_offset: queryParams.offset,
            p_limit: queryParams.limit,
          });
        assets = rpcResult.data;
        error = rpcResult.error;
        source = 'rpc';
      }

      if (queryParams.q || error) {
        if (error) logger.warn('Assets RPC failed/absent, using fallbacks', { error });
        const q = queryParams.q?.replace(/%/g, '\\%').replace(/_/g, '\\_');

        // First fallback: assets table (new system)
        let assetsQuery = supabaseAdmin
          .from('assets')
          .select(`id, filename, preview_path, file_size, created_at, folder_id, status`)
          .in('folder_id', folderIds)
          .order('created_at', { ascending: false })
          .range(queryParams.offset, queryParams.offset + queryParams.limit - 1);

        if (q) {
          assetsQuery = assetsQuery.ilike('filename', `%${q}%`);
        }
        if (queryParams.status) {
          assetsQuery = assetsQuery.eq('status', queryParams.status);
        }
        if (queryParams.min_size) {
          assetsQuery = assetsQuery.gte('file_size', queryParams.min_size);
        }
        if (queryParams.max_size) {
          assetsQuery = assetsQuery.lte('file_size', queryParams.max_size);
        }
        if (queryParams.start_date) {
          assetsQuery = assetsQuery.gte('created_at', queryParams.start_date.toISOString());
        }
        if (queryParams.end_date) {
          assetsQuery = assetsQuery.lte('created_at', queryParams.end_date.toISOString());
        }

        const assetsFallback = await assetsQuery;

        if (!assetsFallback.error && assetsFallback.data) {
          assets = assetsFallback.data;
          error = undefined;
          source = 'assets';
        } else {
          // Second fallback: photos table (legacy/unified mapping to subject_id)
          let photosQuery = supabaseAdmin
            .from('photos')
            .select(`
              id,
              original_filename,
              preview_path,
              watermark_path,
              file_size,
              created_at,
              approved
            `)
            .in('subject_id', folderIds)
            .order('created_at', { ascending: false })
            .range(queryParams.offset, queryParams.offset + queryParams.limit - 1);

          if (q) {
            photosQuery = photosQuery.ilike('original_filename', `%${q}%`);
          }
          if (queryParams.status) {
            if (queryParams.status === 'ready') {
              photosQuery = photosQuery.eq('approved', true);
            } else if (queryParams.status === 'pending') {
              photosQuery = photosQuery.eq('approved', false);
            }
          }
          if (queryParams.min_size) {
            photosQuery = photosQuery.gte('file_size', queryParams.min_size);
          }
          if (queryParams.max_size) {
            photosQuery = photosQuery.lte('file_size', queryParams.max_size);
          }
          if (queryParams.start_date) {
            photosQuery = photosQuery.gte('created_at', queryParams.start_date.toISOString());
          }
          if (queryParams.end_date) {
            photosQuery = photosQuery.lte('created_at', queryParams.end_date.toISOString());
          }

          const photosResult = await photosQuery;
          if (photosResult.data) {
            assets = photosResult.data.map(photo => ({
              id: photo.id,
              filename: photo.original_filename,
              preview_path: photo.preview_path || photo.watermark_path,
              file_size: photo.file_size || 0,
              created_at: photo.created_at,
              status: photo.approved ? 'ready' : 'pending'
            }));
          }
          error = photosResult.error;
          source = 'photos';

          // Legacy variant: photos with folder_id if subject_id not used
          if (error && (error.code === '42P01' || error.code === '42703')) {
            logger.warn('photos table missing expected columns, trying legacy folder_id');
            let legacyQuery = supabaseAdmin
              .from('photos')
              .select(`
                id,
                filename,
                preview_path,
                watermark_path,
                file_size,
                created_at,
                status
              `)
              .in('folder_id', folderIds)
              .order('created_at', { ascending: false })
              .range(queryParams.offset, queryParams.offset + queryParams.limit - 1);

            if (q) {
              legacyQuery = legacyQuery.ilike('filename', `%${q}%`);
            }
            if (queryParams.min_size) {
              legacyQuery = legacyQuery.gte('file_size', queryParams.min_size);
            }
            if (queryParams.max_size) {
              legacyQuery = legacyQuery.lte('file_size', queryParams.max_size);
            }
            if (queryParams.start_date) {
              legacyQuery = legacyQuery.gte('created_at', queryParams.start_date.toISOString());
            }
            if (queryParams.end_date) {
              legacyQuery = legacyQuery.lte('created_at', queryParams.end_date.toISOString());
            }

            const legacyResult = await legacyQuery;
            if (!legacyResult.error) {
              assets = legacyResult.data;
              error = undefined;
              source = 'photos';
            } else {
              error = legacyResult.error;
            }
          }
        }
      }
    } catch (rpcError) {
      logger.warn('Assets fetch error, using fallback error handling', { error: rpcError });
    }

    if (error) {
      logger.error('Database query failed', { 
        error: error.message, 
        code: error.code,
        folderId: queryParams.folder_id,
      });
      
      // Return specific error codes based on error type
      if (error.code === '42P01') { // table does not exist
        return NextResponse.json(
          { success: false, error: 'Database table not found' },
          { status: 404 }
        );
      }
      if (error.code === '42501') { // insufficient privilege
        return NextResponse.json(
          { success: false, error: 'Database access denied' },
          { status: 403 }
        );
      }
      
      return NextResponse.json(
        { success: false, error: 'Database query failed' },
        { status: 500 }
      );
    }

    // Get total count efficiently (with error handling) based on source
    let totalCount = 0;
    try {
      const sbCount = await createServerSupabaseServiceClient();
      // Recompute folder set if include_children is requested
      const folderIds = queryParams.include_children
        ? (await (async () => {
            try {
              const sb = await createServerSupabaseServiceClient();
              const rpcDesc = await sb.rpc('get_descendant_folders', { p_folder_id: queryParams.folder_id });
              if (!rpcDesc.error && Array.isArray(rpcDesc.data)) {
                const ids = rpcDesc.data.map((r: any) => r.id || r.folder_id).filter(Boolean);
                return Array.from(new Set([queryParams.folder_id, ...ids])).slice(0, 200);
              }
            } catch {}
            return [queryParams.folder_id];
          })())
        : [queryParams.folder_id];

      if (source === 'assets' || source === 'rpc') {
        let c1Query = sbCount
          .from('assets')
          .select('id', { count: 'exact', head: true })
          .in('folder_id', folderIds);
        if (queryParams.status) c1Query = c1Query.eq('status', queryParams.status);
        if (queryParams.q) {
          const q = queryParams.q.replace(/%/g, '\\%').replace(/_/g, '\\_');
          c1Query = c1Query.ilike('filename', `%${q}%`);
        }
        if (queryParams.min_size) c1Query = c1Query.gte('file_size', queryParams.min_size);
        if (queryParams.max_size) c1Query = c1Query.lte('file_size', queryParams.max_size);
        if (queryParams.start_date) c1Query = c1Query.gte('created_at', queryParams.start_date.toISOString());
        if (queryParams.end_date) c1Query = c1Query.lte('created_at', queryParams.end_date.toISOString());
        const c1 = await c1Query;
        if (!c1.error) {
          totalCount = c1.count || 0;
        } else {
          let c2Query = sbCount
            .from('photos')
            .select('id', { count: 'exact', head: true })
            .in('subject_id', folderIds);
          if (queryParams.q) {
            const q = queryParams.q.replace(/%/g, '\\%').replace(/_/g, '\\_');
            c2Query = c2Query.ilike('original_filename', `%${q}%`);
          }
          if (queryParams.start_date) c2Query = c2Query.gte('created_at', queryParams.start_date.toISOString());
          if (queryParams.end_date) c2Query = c2Query.lte('created_at', queryParams.end_date.toISOString());
          const c2 = await c2Query;
          totalCount = c2.count || 0;
        }
      } else {
        let c3Query = sbCount
          .from('photos')
          .select('id', { count: 'exact', head: true })
          .in('subject_id', folderIds);
        if (queryParams.q) {
          const q = queryParams.q.replace(/%/g, '\\%').replace(/_/g, '\\_');
          c3Query = c3Query.ilike('original_filename', `%${q}%`);
        }
        if (queryParams.start_date) c3Query = c3Query.gte('created_at', queryParams.start_date.toISOString());
        if (queryParams.end_date) c3Query = c3Query.lte('created_at', queryParams.end_date.toISOString());
        const c3 = await c3Query;
        if (!c3.error) {
          totalCount = c3.count || 0;
        } else {
          let c4Query = sbCount
            .from('assets')
            .select('id', { count: 'exact', head: true })
            .in('folder_id', folderIds)
            .eq('status', 'ready');
          if (queryParams.q) {
            const q = queryParams.q.replace(/%/g, '\\%').replace(/_/g, '\\_');
            c4Query = c4Query.ilike('filename', `%${q}%`);
          }
          if (queryParams.min_size) c4Query = c4Query.gte('file_size', queryParams.min_size);
          if (queryParams.max_size) c4Query = c4Query.lte('file_size', queryParams.max_size);
          if (queryParams.start_date) c4Query = c4Query.gte('created_at', queryParams.start_date.toISOString());
          if (queryParams.end_date) c4Query = c4Query.lte('created_at', queryParams.end_date.toISOString());
          const c4 = await c4Query;
          totalCount = c4.count || 0;
        }
      }
    } catch (countErr) {
      logger.warn('Failed to get asset count', { error: countErr });
    }

    // Transform to minimal interface with safe defaults and fallback for preview_path
    const assetList: AssetListItem[] = (assets || []).map(asset => ({
      id: asset.id,
      filename: asset.filename || 'Untitled',
      preview_path: asset.preview_path || null,
      file_size: asset.file_size || 0,
      created_at: asset.created_at,
    }));

    const hasMore = queryParams.offset + queryParams.limit < totalCount;

    // Log egress usage for monitoring
    const responseSize = JSON.stringify(assetList).length;
    logger.info('Assets fetched successfully', {
      folderId: queryParams.folder_id,
      count: assetList.length,
      totalBytes: responseSize,
      egressOptimized: responseSize < 10000, // Flag large responses
    });

    return NextResponse.json(
      {
        success: true,
        assets: assetList,
        count: totalCount,
        hasMore,
        // Backward compatibility fields expected by some tests/clients
        totalCount: totalCount,
        pagination: {
          limit: queryParams.limit,
          offset: queryParams.offset,
          hasMore,
        },
      },
      {
        headers: {
          // Small private cache to smooth out navigation spikes
          'Cache-Control': 'private, max-age=15, stale-while-revalidate=60',
        },
      }
    );

  } catch (error) {
    if (error instanceof z.ZodError) {
      logger.warn('Invalid asset query', { errors: error.errors });
      return NextResponse.json(
        { success: false, error: 'Invalid query parameters' },
        { status: 400 }
      );
    }

    logger.error('Assets API error', { error: error instanceof Error ? error.message : error });
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/admin/assets
 * Upload asset with processing queue
 */
async function handlePOST(request: NextRequest) {
  try {
    // Rate limiting applied by wrapper below

    // Parse and validate request body
    const body = await request.json();
    const assetData = uploadAssetSchema.parse(body);

    // Verify folder exists
    const supabaseAdmin = await createServerSupabaseServiceClient();
    const { data: folder } = await supabaseAdmin
      .from('folders')
      .select('id')
      .eq('id', assetData.folder_id)
      .single();

    if (!folder) {
      return NextResponse.json(
        { success: false, error: 'Folder not found' },
        { status: 404 }
      );
    }

    // Check for duplicate checksum (deduplication)
    const { data: existing } = await supabaseAdmin
      .from('assets')
      .select('id, filename')
      .eq('checksum', assetData.checksum)
      .single();

    if (existing) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Duplicate file detected',
          existing_filename: existing.filename,
        },
        { status: 409 }
      );
    }

    // Generate secure paths
    const fileId = nanoid(12);
    const fileExt = assetData.filename.split('.').pop()?.toLowerCase();
    const originalPath = `originals/${fileId}.${fileExt}`;

    // Create asset record with minimal data
    const { data: asset, error: insertError } = await supabaseAdmin
      .from('assets')
      .insert({
        folder_id: assetData.folder_id,
        filename: assetData.filename,
        original_path: originalPath,
        preview_path: null, // Will be set after processing
        file_size: assetData.file_size,
        checksum: assetData.checksum,
        mime_type: assetData.mime_type,
        status: 'pending',
      })
      .select('id')
      .single();

    if (insertError) {
      logger.error('Failed to create asset record', { 
        error: insertError.message,
        asset: assetData,
      });
      return NextResponse.json(
        { success: false, error: 'Failed to create asset' },
        { status: 500 }
      );
    }

    // Generate signed upload URL (24h expiry)
    const { data: uploadData, error: uploadError } = await supabaseAdmin
      .storage
      .from('photo-private')
      .createSignedUploadUrl(originalPath, {
        expiresIn: 86400, // 24 hours
        upsert: false,
      });

    if (uploadError) {
      // Cleanup asset record on failure
      await supabaseAdmin
        .from('assets')
        .delete()
        .eq('id', asset.id);

      logger.error('Failed to create upload URL', { 
        error: uploadError.message,
        assetId: asset.id,
      });
      return NextResponse.json(
        { success: false, error: 'Failed to create upload URL' },
        { status: 500 }
      );
    }

    const response: UploadAssetResponse = {
      id: asset.id,
      upload_url: uploadData.signedUrl,
      expires_at: new Date(Date.now() + 86400000).toISOString(),
    };

    logger.info('Asset upload URL created', {
      assetId: asset.id,
      filename: assetData.filename,
      folderId: assetData.folder_id,
    });

    return NextResponse.json({
      success: true,
      asset: response,
    }, { status: 201 });

  } catch (error) {
    if (error instanceof z.ZodError) {
      logger.warn('Invalid asset data', { errors: error.errors });
      return NextResponse.json(
        { success: false, error: 'Invalid asset data', details: error.errors },
        { status: 400 }
      );
    }

    logger.error('Upload asset API error', { error });
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export const GET = RateLimitMiddleware.withRateLimit(withAuth(handleGET));
export const POST = RateLimitMiddleware.withRateLimit(withAuth(handlePOST));

export const runtime = 'nodejs';
